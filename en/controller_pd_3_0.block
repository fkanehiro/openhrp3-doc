title = Controller Building Guide<br> (Walking Pattern)
base  = ..

<h2> Overview </h2>

<p>
Here we describe the procedure of building a controller as an OpenRTM component. We take SamplePD 
as for the example, that makes a robot walk by PD-control based on walking pattern files. The process 
of making the component is carried out by referring to the sample source codes (SamplePD.h, 
Sample.cpp) we have provided in OpenHRP source package. Codes that are skipped explaining is referred 
to the skeleton parts generated by rtc-template. Creating skeleton of a OpenRTM component using 
rtc-template is described later in <a href="#rtc_template">"Skeleton Generation"</a> section.
</p>
<br>


<h2>Code Explanation</h2>

<h3> SamplePD.h </h3>

<p>
Please look at <i>"Controller/rtc/SamplePD/SamplePD.h"</i> .
</p>

<p>
Confirm if <i>"SamplePD::onActivated"</i> and <i>"SamplePD::onExecute"</i> are declared in it.
Virtual functions other than <i>"SamplePD::onInitialize"</i>, are kept commented out while generating 
skeletons. By overriding these virtual functions, we can define peculiar behavior to the controller. 
</p>

<p>
Various members used by controller, are added.
</p>

<pre>
private: 
  int dummy; 
  std::ifstream angle, vel, gain; // Joint-angle, Joint-angular-velocity, gain value
  double *Pgain;                  // Array of Pgain
  double *Dgain;                  // Array of Dgain
  std::vector&lt;double&gt; qold;       // Preserve previous Joint-angle 
</pre>

<p>
When building on Windows environment, it is necessary to modify the method <i>"SamplePDInit"</i> to 
refer the macro <i>"DLL_EXPORT"</i> defined by OpenRTM; so that it will support Windows-DLL builds.
</p>

<pre>
extern "C"
{

  DLL_EXPORT void SamplePDInit(RTC::Manager* manager);

};
</pre>


<h3> SamplePD.cpp </h3>

<p>
First, we declare header file includes and macro. 
</p>

<pre>
#include &lt;iostream&gt;

#define DOF (29)       // Degree of freedom
#define TIMESTEP 0.002 // Simulation Time-step (time unit)

// File group
#define ANGLE_FILE "etc/angle.dat"  // Joint-angle
#define VEL_FILE   "etc/vel.dat"    // Joint-angular-velocity
#define GAIN_FILE  "etc/PDgain.dat" // PDgain value
</pre>

<p>
Now, let us implement the methods we declared in <i>"SamplePD.h"</i>.
</p>

<p>
After the constructor <i>"SamplePD::SamplePD"</i> is called, the walking pattern file is opened and 
the PD gain values are taken from the gain file and substitute to the variables. 
</p>

<pre>
SamplePD::SamplePD(RTC::Manager* manager)
  : RTC::DataFlowComponentBase(manager),
    // &lt;rtc-template block="initializer"&gt;
    m_angleIn("angle", m_angle),
    m_torqueOut("torque", m_torque),
    
    // &lt;/rtc-template&gt;
    dummy(0),
    qold(DOF)
{

...

  Pgain = new double[DOF];
  Dgain = new double[DOF];

  // Opening joint-angle file
  if (access(ANGLE_FILE, 0)){
    std::cerr << ANGLE_FILE << " not found" << std::endl;
  }else{
    angle.open(ANGLE_FILE);
  }

  // Opening joint-angular-velocity file
  if (access(VEL_FILE, 0)){
    std::cerr << VEL_FILE << " not found" << std::endl;
  }else{
    vel.open(VEL_FILE);
  }

  // Opening gain file and substituting to array
  if (access(GAIN_FILE, 0)){
    std::cerr << GAIN_FILE << " not found" << std::endl;
  }else{
    gain.open(GAIN_FILE);
    for (int i=0; i&lt;DOF; i++){
      gain >> Pgain[i];
      gain >> Dgain[i];
    }
    gain.close();
  }

  // Ensuring the length of torque and joint-angle port, 
  // to the size of degree-of-freedom(DOF) of the robot
  m_torque.data.length(DOF);
  m_angle.data.length(DOF);
}
</pre>

<p>
<i>"SamplePD::~SamplePD"</i> method is used to freeing arrays and close the file.
</p>

<pre>
  if (angle.is_open()) angle.close();
  if (vel.is_open()) vel.close();
  delete [] Pgain;
  delete [] Dgain;
</pre>

<p>
Initializing is done by <i>"RTC::ReturnCode_t SamplePD::onActivated"</i>.
</p>

<pre>
RTC::ReturnCode_t SamplePD::onActivated(RTC::UniqueId ec_id)
{
  std::cout << "on Activated" << std::endl;
  angle.seekg(0);
  vel.seekg(0);

  // Updating the joint-angle InPort value
  m_angleIn.update();

  // Preserve the values of previous frame
  for(int i=0; i &lt; DOF; ++i){
    qold[i] = m_angle.data[i];
  }

  return RTC::RTC_OK;
}
</pre>

<p>
<i>"RTC::ReturnCode_t SamplePD::OnExecute"</i> method is used to process the behavior in each step of 
the simulation.
</p>

<pre>
RTC::ReturnCode_t SamplePD::onExecute(RTC::UniqueId ec_id)
{
  // Updating the joint-angle InPort value
  m_angleIn.update();

  // Updating angle and angular-velocity of each joint
  static double q_ref[DOF], dq_ref[DOF];
  if(!angle.eof()){
    angle >> q_ref[0]; vel >> dq_ref[0];// skip time
    for (int i=0; i&lt;DOF; i++){
      angle >> q_ref[i];
      vel >> dq_ref[i];
    }
  }
  
  // Calculating torque of the each joint
  for(int i=0; i&lt;DOF; i++){
    double q = m_angle.data[i];
    double dq = (q - qold[i]) / TIMESTEP;
    qold[i] = q;
    
    m_torque.data[i] = -(q - q_ref[i]) * Pgain[i] - (dq - dq_ref[i]) * Dgain[i];
  }  
  
  // Outputs torque
  m_torqueOut.write();
  
  return RTC::RTC_OK;
}
</pre>
<br>


<h2>Files</h2>

<p>
In this section we describe about pattern files and configuration files at 
<i>"Controller/rtc/SamplePD/"</i>.
</p>


<h3> Walking Pattern Files </h3>

<p>
These files are related to the "ANGLE_FILE" macro and "VEL_FILE" macro in the code. 
First let us explain the format of Waking Pattern Files(angle.dat, vel.dat). 
Format of one line in each pattern file is as follows;
</p>

<pre>
Time  &lt;Joint-Data where JointID=0&gt;  &lt;Joint-Data where JointID=1&gt; ....  &lt;Joint-Data where JointID=n&gt;
</pre>

<p>
One line corresponds to one frame, and each data in a line are delimited by tab.
Time refers to the time-duration elapsed from starting-time. Joint-data refers to joint-angle in 
<i>"angle.dat"</i> and it refers to joint-angular-velocity in <i>"vel.dat"</i>.
</p>

<p>
For instance, 29 joint-data of 6701 frames that executes for 14 seconds has been expressed 
in the given sample files. 
</p>


<h3> Gain File </h3>

<p>
This file is related to the "GAIN_FILE" macro in the code.
Gain file is used to keep records of PD-control gains. Basically it consists of a collection of 
P-gains and D-gains. Each line corresponds to JointID number. An arbitrary number of P-gains and 
D-gains (corresponding with JointID) can be written per line, delimiting with spaces.<br>
Concretely it can be described as follows;
</p>
<pre>
P-Gain D-Gain (&lt;= JointID = 0)
P-Gain D-Gain (&lt;= JointID = 1)
...
P-Gain D-Gain (&lt;= JointID = n)
</pre>


<h3> rtc.conf </h3>

<p>
Please look at the cofiguration file <i>"rtc.conf"</i> available at <i>"Controller/rtc/SamplePD/rtc.conf"</i>.<br> 
This is used to describe the configuration of RT-Component.
</p>

<p>
Specify the location(ip address) of the nameserver, according to your environment.

<pre>
corba.nameservers: localhost:2809
</pre>

Specially when <a href="./howtomake.html#NS_HOST"><i>"NS_HOST"</i></a> and 
<a href="./howtomake.html#NS_PORT"><i>"NS_PORT"</i></a> do not take the default values on your 
environment, you have to specify the correct values in following files.
<ul>
  <i>Make.vars</i>, <i>bin/unix/config.sh</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(On Unix)<br>
  <i>OpenHRP.vsprops</i>, <i>bin/dos/config.bat</i> &nbsp;&nbsp;(On Windows)<br>
</ul>
</p>
<br>

<p>
Specify the settings regarding with log files. 
</p>
<ul>
  <li>To disable creating log files; 
    <ul>
     <pre>logger.enable:NO</pre>
    </ul>
  </li>
  <li>To enable creating log files; 
    <ul>
     <pre>logger.enable:YES</pre>
    </ul>
  </li>
  <p>
  Specify the log file's name format and saving location(path).<br>
  You can also specify the direct path as shown below. 
  </p>
  <ul>
   <pre>logger.file_name: D:<span lang="en">\\</span>Temp<span lang="en">\\</span>rtc%p.log</pre>
  </ul>
  <p>
  Set the log level. 
  </p>
  <ul>
   <pre>logger.log_level: TRACE</pre>
  </ul>
</ul>
<p>
Normally you don't have to change the following contents.
</p>
<pre>
naming.formats: %n.rtc
manager.modules.load_path: .
exec_cxt.periodic.rate: 1000000
manager.modules.abs_path_allowed: yes
exec_cxt.periodic.type: SynchExtTriggerEC
</pre>
<p>
Please refer OpenRTM 
<a href="http://www.is.aist.go.jp/rt/OpenRTM-aist/html-en/Documents2FConfiguration.html" target="_blank">Configuaration</a>
 manual, for detailed explanation about RT-components' configuration options.
</p>
<br>


<h2> Controller-bridge Settings and Execution </h2>

<p>
The purpose of separating the implementation of each RT-component is to improve the maintainability 
and the portability upon development process. The controller bridge is the process which manage 
input/outputs(I/O) between the simulating model and each OpenRTM component. Here we describe, how 
to launch controller-bridge and its connection settings with components.
</p>

<h3> For Linux </h3>

<p>
Run the shell-script <i>"SamplePD.sh"</i>, available at <i>"Controller/rtc/SamplePD/"</i>.<br>
</p>

<pre>
#!/bin/sh

CONTROLLER_BRIDGE_DIR=../../bridge
if [ -z $NS_HOST ]; then
    if [ -z $NS_PORT ]; then
        . $CONTROLLER_BRIDGE_DIR/../../bin/unix/config.sh
    fi
fi
$CONTROLLER_BRIDGE_DIR/ControllerBridge <span lang="en">\</span>
--config-file bridge.conf <span lang="en">\</span>
--name-server $NS_HOST:$NS_PORT
</pre>

<p>
Reference to ControllerBridge may loss, if relative paths to <i>"Controller/bridge"</i> 
directory and <i>"Controller/SamplePD"</i> directory are changed. You can fix this by changing 
<i>"CONTROLLER_BRIDGE_DIR"</i> field appropriately. If neither environment variable NS_HOST nor 
NS_PORT are defined, it acquires them from <i>"bin/unix/config.sh"</i>. 
</p>


<h3> For Windows </h3>

<p>
Run the batch file <i>"SamplePD.bat"</i>, available at <i>"Controller/rtc/SamplePD/"</i>.
</p>

<pre>
SET CONTROLLER_BRIDGE_DIR=..<span lang="en">\</span>..<span lang="en">\</span>bridge
@echo off
if "%NS_HOST%" == "" (
    if "%NS_PORT%" == "" (
        call %CONTROLLER_BRIDGE_DIR%<span lang="en">\</span>..<span lang="en">\</span>..<span lang="en">\</span>bin<span lang="en">\</span>dos<span lang="en">\</span>config.bat
    )
)
@echo on

%CONTROLLER_BRIDGE_DIR%<span lang="en">\</span>ControllerBridge ^
--config-file bridge.conf ^
--name-server %NS_HOST%:%NS_PORT%
</pre>

<p>
As same as Linux, reference to the ControllerBridge may loss, if relative paths to 
<i>"Controller/bridge"</i> directory and <i>"Controller/SamplePD"</i> directory are changed. 
You can fix this problem by changing <i>"CONTROLLER_BRIDGE_DIR"</i> field appropriately. 
If neither environment variable NS_HOST nor NS_PORT are defined, it acquires them from 
<i>"bin/unix/config.sh"</i>. Moreover, please beware to enclose the path name with double 
cotations, if it contains spaces. 
</p>

<p>
There is something to beware of this batch file execution on windows environments.
Unlike Unix environments, omninames server does not register as a service on windows environments 
at most cases. In such situation, it is necessary to start the omninames server beforehand. 
</p>

<p>
To refer the starting procedure of omninames server, visit 
<a href="http://www.is.aist.go.jp/rt/OpenRTM-aist/html-en/Documents2FDevelopment20of20RT-Component2028VC2B2B29.html" target="_blank">"Development of RT-Component (VC++)"</a>
page at OpenRTM documentations and find the title "Starting CORBA Name Server".</p>

<p>
Or if you can start GrxUI beforehand and keep it working, omninames 
server also get started with GrxUI and continue to work. However if you use this method, omninames server will 
also be exit, with the termination of GrxUI.
</p>


<h3>Start-Options</h3>

<p>
<b>config-file</b><br>
Specifies the configuration file that contains start-options.<br>
This corresponds to <i>"bridge.conf"</i>, in the above notation.
</p>

<p>
<b>name-server</b><br>
Specifies the host-namet and port-number of the nameserver.<br>
Host-name corresponds to NS_HOST, and port-number corresponds to NS_PORT, in the above notation.
</p>

<p>
Please refer <a href="./controller_bridge.html">Controller-Bridge</a> user manual 
for more details about start options.
</p>


<h3> Loading Project File and Simulation Execution </h3>

<p>
Load the project file to GrxUI and start the simulation process according to the following 
steps.
</p>

<ol>
  <li>
    Select <i>"File"</i> -> <i>"Load Project"</i> from menubar. <i>"Open Project File"</i> dialog 
    box will be displayed. Find the project file <i>"SamplePD.xml"</i> and load onto GrxUI.
  </li>
  <li>
    Press <i>"Start Simulation"</i> button to start the 
    simulation process.
  </li>
   <p align="left">
   <img src="../image/Simulation_Button.png" align="top"><br>
   Figure 1 : Simulation Button
  </p>
  <li>
    Select "No", if you get a dialog box as shown in Figure 2.
  </li>
  <p align="left">
   <img src="../image/GrxUI_RestartDlg.png" align="top"><br>
   Figure 2 : <i>"Restart the Controller"</i> dialog
  </p>
</ol>

<p>
Please refer <a href="./OpenHRP3_GrxUI_20080611_3.pdf">GrxUI User Manual</a> for more about GrxUI.
</p>
<br>

<name id=rtc_template></name>
<h2> Skeleton Generation </h2>

<p>
In this section we describe generating skeleton of a OpenRTM component using rtc-template.
Although it is possible to generate the skeleton using command-line, we recommand you to 
prepare a script file, since there are lot of settings.</p>
<p>
As you execute this script, it will generate the skeleton of the "SamplePD" component having one 
Inport named <i>"angle"</i> and one OutPort named </i>"torque"</i>.
</p>

<h3> For Linux </h3>

<p>
Prepare a shell-script as follows;
</p>

<pre>
#!/bin/sh

rtc-template -bcxx <span lang="en">\</span>
--module-name=SamplePD --module-desc="SamplePD component" <span lang="en">\</span>
--module-version=0.1 --module-vendor=AIST --module-category=Generic <span lang="en">\</span>
--module-comp-type=DataFlowComponent --module-act-type=SPORADIC <span lang="en">\</span>
--module-max-inst=1  <span lang="en">\</span>
--inport=angle:TimedDoubleSeq <span lang="en">\</span>
--outport=torque:TimedDoubleSeq
</pre>

<p>
Please refer <a href="http://www.is.aist.go.jp/rt/OpenRTM-aist/html-en/Documents2FDevelopment20of20RT-Component.html" target="_blank">"Development of RT-Component"</a> 
page in OpenRTM documentations, for more details on rtc-template (Linux C++ edition).
</p>


<h3> For Windows </h3>

<p>
Prepare a batch file as follows;
</p>

<pre>
"C:<span lang="en">\</span>Program Files<span lang="en">\</span>OpenRTM-aist<span lang="en">\</span>0.4<span lang="en">\</span>utils<span lang="en">\</span>rtc-template<span lang="en">\</span>rtc-template.py" -bcxx ^
--module-name=SamplePD --module-desc="SamplePD component" ^
--module-version=0.1 --module-vendor=AIST --module-category=Generic ^
--module-comp-type=DataFlowComponent --module-act-type=SPORADIC ^
--module-max-inst=1 ^
--inport=angle:TimedDoubleSeq ^
--outport=torque:TimedDoubleSeq
</pre>

<p>
Executing this batch file will produce a solution file and a project file for VC++ 2008. After that 
run <i>"copyprops.bat"</i>, generated by rtc-template.
</p>

<p>
For concrete explanation regarding rtc-template (Windows VC++ edition), please refer 
<a href="http://www.is.aist.go.jp/rt/OpenRTM-aist/html-en/Documents2FDevelopment20of20RT-Component2028VC2B2B29.html" target="_blank">"Development of RT-Component (VC++)"</a> 
page in OpenRTM documentations.
</p>
<br>